/**
 * ## Static syntax highlighting extension for code-to-HTML conversion
 *
 * Transforms code snippets into syntax-highlighted HTML with CSS styling without requiring a live editor instance.
 * Uses a simplified DOM implementation to generate standalone HTML output suitable for static content generation,
 * documentation, code export, and embedding highlighted code in web pages. Supports automatic language detection
 * from CSS classes and custom modes/themes.
 *
 * @module
 */


"use strict";
/**
 * @typedef {SyntaxMode} SyntaxMode
 * @typedef {Theme} Theme
 */


import {EditSession} from "../edit_session";
import {Text as TextLayer} from "../layer/text";
import "./static-css";
import config from "../config";
import * as dom from "../lib/dom";
import {escapeHTML} from "../lib/lang";
import type {View} from "quark";
import type { SyntaxMode } from "../mode";
import { getChildren } from "../lib/dom";

class Element {
	className: string;
	type: string;
	style: Dict;
	textContent: string;

	/**
	 * @param {string} type
	 */
	constructor(type: string) {
		/** @type{string} */this.className;
		this.type = type;
		this.style = {};
		this.textContent = "";
	}

	cloneNode() {
		return this;
	}

	appendChild(child: Element) {
		this.textContent += child.toString();
	}

	toString() {
		var stringBuilder = [];
		if (this.type != "fragment") {
			stringBuilder.push("<", this.type);
			if (this.className)
				stringBuilder.push(" class='", this.className, "'");
			var styleStr = [];
			for (var key in this.style) {
				styleStr.push(key, ":", this.style[key]);
			}
			if (styleStr.length)
				stringBuilder.push(" style='", styleStr.join(""), "'");
			stringBuilder.push(">");
		}

		if (this.textContent) {
			stringBuilder.push(this.textContent);
		}

		if (this.type != "fragment") {
			stringBuilder.push("</", this.type, ">");
		}

		return stringBuilder.join("");
	}
}


var simpleDom = {
	createTextNode: function(textContent: string, element: Element) {
		return escapeHTML(textContent);
	},
	createElement: function(type: string) {
		return new Element(type);
	},
	createFragment: function() {
		return new Element("fragment");
	}
};

class SimpleTextLayer {
	config = {};
	dom = simpleDom;
};
(SimpleTextLayer as any).prototype = TextLayer.prototype;

export interface StaticHighlightOptions {
	/** Syntax mode (e.g., 'ace/mode/javascript'). Auto-detected from CSS class if not provided */
	mode?: string | SyntaxMode,
	/** Color theme (e.g., 'ace/theme/textmate'). Defaults to 'ace/theme/textmate' */
	theme?: string | Ace.Theme,
	/** Whether to trim whitespace from code content */
	trim?: boolean,
	/** Starting line number for display */
	firstLineNumber?: number,
	/** Whether to show line numbers gutter */
	showGutter?: boolean
}

/**
 * Applies syntax highlighting to an HTML element containing code.
 *
 * Automatically detects the language from CSS class names (e.g., 'lang-javascript') or uses
 * the specified mode. Transforms the element's content into syntax-highlighted HTML with
 * CSS styling and preserves any existing child elements by repositioning them after highlighting.
 *
 * @param {View} el - The HTML element containing code to highlight
 * @param {StaticHighlightOptions} opts - Highlighting options
 * @param {function} [callback] - Optional callback executed after highlighting is complete
 * @returns {boolean} Returns false if no valid mode is found, otherwise true
 */
var highlight = function(el: View, opts: StaticHighlightOptions, callback?: () => void): boolean {
	var m = el.class.join(' ').match(/lang-(\w+)/);
	var mode = opts.mode || m && ("ace/mode/" + m[1]);
	if (!mode)
		return false;
	var theme = opts.theme || "ace/theme/textmate";

	var data = "";
	var nodes = [];

	if (el.first) {
		var textLen = 0;
		var childNodes = getChildren(el);
		for (var i = 0; i < childNodes.length; i++) {
			var ch = childNodes[i];
			if (ch.nodeType == 3) {
				textLen += ch.data.length;
				data += ch.data;
			} else {
				nodes.push(textLen, ch);
			}
		}
	} else {
		data = el.textContent;
		if (opts.trim)
			data = data.trim();
	}

	highlight.render(data, mode, theme, opts.firstLineNumber, !opts.showGutter, function (highlighted) {
		dom.importCssString(highlighted.css, "ace_highlight", true);
		el.innerHTML = highlighted.html;
		/**
		 * TODO: check if child exists
		 * @type {any}
		 */
		var container = el.firstChild.firstChild;
		for (var i = 0; i < nodes.length; i += 2) {
			var pos = highlighted.session.doc.indexToPosition(nodes[i]);
			var node = nodes[i + 1];
			var lineEl = container.children[pos.row];
			lineEl && lineEl.appendChild(node);
		}
		callback && callback();
	});
	return true;
};

/**
 * Transforms a given input code snippet into HTML using the given mode
 *
 * @param {string} input Code snippet
 * @param {string | SyntaxMode} mode String specifying the mode to load such as
 *  `ace/mode/javascript` or, a mode loaded from `/ace/mode`
 *  (use 'ServerSideHiglighter.getMode').
 * @param {string | Theme} theme String specifying the theme to load such as
 *  `ace/theme/twilight` or, a theme loaded from `/ace/theme`.
 * @param {number} lineStart A number indicating the first line number. Defaults
 *  to 1.
 * @param {boolean} disableGutter Specifies whether or not to disable the gutter.
 *  `true` disables the gutter, `false` enables the gutter. Defaults to `false`.
 * @param {function} [callback] When specifying the mode or theme as a string,
 *  this method has no return value and you must specify a callback function. The
 *  callback will receive the rendered object containing the properties `html`
 *  and `css`.
 * @returns {object} An object containing the properties `html` and `css`.
 */
highlight.render = function(input, mode, theme, lineStart, disableGutter, callback) {
	var waiting = 1;
	var modeCache = EditSession.prototype.$modes;

	// if either the theme or the mode were specified as objects
	// then we need to lazily load them.
	if (typeof theme == "string") {
		waiting++;
		config.loadModule(['theme', theme], function(m) {
			theme = m;
			--waiting || done();
		});
	}
	// allow setting mode options e.h {path: "ace/mode/php", inline:true}
	var modeOptions;
	if (mode && typeof mode === "object" && !mode.getTokenizer) {
		modeOptions = mode;
		mode = modeOptions.path;
	}
	if (typeof mode == "string") {
		waiting++;
		config.loadModule(['mode', mode], function(m) {
			if (!modeCache[/**@type{string}*/(mode)] || modeOptions)
				modeCache[/**@type{string}*/(mode)] = new m.Mode(modeOptions);
			mode = modeCache[/**@type{string}*/(mode)];
			--waiting || done();
		});
	}

	// loads or passes the specified mode module then calls renderer
	function done() {
		var result = highlight.renderSync(input, mode, /**@type{Theme}*/(theme), lineStart, disableGutter);
		return callback ? callback(result) : result;
	}
	return --waiting || done();
};

/**
 * Transforms a given input code snippet into HTML using the given mode
 * @param {string} input Code snippet
 * @param {SyntaxMode | string} mode Mode loaded from /ace/mode (use 'ServerSideHiglighter.getMode')
 * @param {Theme} theme
 * @param {any} lineStart
 * @param {boolean} disableGutter
 * @returns {object} An object containing: html, css
 */
highlight.renderSync = function(input, mode, theme, lineStart, disableGutter) {
	lineStart = parseInt(lineStart || 1, 10);

	var session = new EditSession("");
	session.setUseWorker(false);
	session.setMode(mode);

	/**@type {TextLayer}*/
	var textLayer = new SimpleTextLayer();
	textLayer.setSession(session);
	Object.keys(textLayer.$tabStrings).forEach(function(k) {
		if (typeof textLayer.$tabStrings[k] == "string") {
			var el = simpleDom.createFragment();
			el.textContent = textLayer.$tabStrings[k];
			textLayer.$tabStrings[k] = el;
		}
	});

	session.setValue(input);
	var length =  session.getLength();

	var outerEl = simpleDom.createElement("div");
	outerEl.className = theme.cssClass;

	var innerEl = simpleDom.createElement("div");
	innerEl.className = "ace_static_highlight" + (disableGutter ? "" : " ace_show_gutter");
	innerEl.style["counter-reset"] = "ace_line " + (lineStart - 1);

	for (var ix = 0; ix < length; ix++) {
		var lineEl = simpleDom.createElement("div");
		lineEl.className = "ace_line";

		if (!disableGutter) {
			var gutterEl = simpleDom.createElement("span");
			gutterEl.className ="ace_gutter ace_gutter-cell";
			gutterEl.textContent = ""; /*(ix + lineStart) + */
			lineEl.appendChild(gutterEl);
		}
		textLayer.$renderLine(lineEl, ix, false);
		lineEl.textContent += "\n";
		innerEl.appendChild(lineEl);
	}

	//console.log(JSON.stringify(outerEl, null, 2));
	//console.log(outerEl.toString());
	outerEl.appendChild(innerEl);

	return {
		css: baseStyles + theme.cssText,
		html: outerEl.toString(),
		session: session
	};
};

module.exports = highlight;
module.exports.highlight = highlight;
